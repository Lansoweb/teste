# .github/workflows/release-manager.yml
name: Release Manager

on:
  workflow_dispatch:
    inputs:
      operation:
        description: 'Git Flow Operation'
        required: true
        type: choice
        options:
          - start-release
          - finish-release
          - start-hotfix
          - finish-hotfix
      release_type: # Only relevant for 'start-release'/'start-hotfix'
        description: 'Type of version bump (patch, minor, major) for new releases/hotfixes'
        required: false
        default: patch
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  manage-git-flow:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for accurate branch operations

      - name: Configure Git User
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      # -------------------------------------------------------------------
      # Step to determine new version only for 'start' operations
      - name: Calculate New Version (for start operations) ðŸš€
        id: calculate_new_version
        if: startsWith(github.event.inputs.operation, 'start-')
        run: |
          latest=$(git tag --sort=-v:refname | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+' | head -n 1)
          latest=${latest#v}
          echo "Current latest version: $latest"

          IFS='.' read -r major minor patch <<< "$latest"

          case "${{ github.event.inputs.release_type }}" in
            major)
              new_version="$((major + 1)).0.0"
              ;;
            minor)
              new_version="$major.$((minor + 1)).0"
              ;;
            patch|*)
              new_version="$major.$minor.$((patch + 1))"
              ;;
          esac

          echo "Calculated new version: $new_version"
          echo "new_version=$new_version" >> "$GITHUB_OUTPUT"

      # -------------------------------------------------------------------
      # Detect existing release/hotfix branch and set operation version
      # Detect existing release/hotfix branch and set operation version
      # Detect existing release/hotfix branch and set operation version
      - name: Detect Operation Version and Branch ðŸŽ¯
        id: detect_op_info
        run: |
          OP_VERSION=""
          TARGET_BRANCH=""
          OPERATION_INPUT="${{ github.event.inputs.operation }}" # Get the input once

          if [[ "$OPERATION_INPUT" == start-* ]]; then
            # For 'start' operations, use the calculated new version
            OP_VERSION="${{ steps.calculate_new_version.outputs.new_version }}"
            if [ "$OPERATION_INPUT" == "start-release" ]; then
              TARGET_BRANCH="release/$OP_VERSION"
            else # start-hotfix
              TARGET_BRANCH="hotfix/$OP_VERSION"
            fi
            echo "Operation: START. Version: $OP_VERSION, Branch: $TARGET_BRANCH"
          elif [[ "$OPERATION_INPUT" == finish-* ]]; then
            # For 'finish' operations, detect the existing branch
            BRANCH_PREFIX=""
            if [ "$OPERATION_INPUT" == "finish-release" ]; then
              BRANCH_PREFIX="release/"
            else # finish-hotfix
              BRANCH_PREFIX="hotfix/"
            fi

            # --- FIX IS HERE ---
            # Escape forward slashes in BRANCH_PREFIX for sed
            ESCAPED_BRANCH_PREFIX=$(echo "$BRANCH_PREFIX" | sed 's/\//\\\//g')


            # Find branches matching the prefix
            matching_branches=$(git branch -r --list "origin/$BRANCH_PREFIX*" | sed "s/.*origin\///" | tr -d '[:space:]')
            
            # Count them
            num_matching=$(printf '%s\n' "$matching_branches" | grep -c .)

            if [ "$num_matching" -eq 0 ]; then
              echo "Error: No active '${BRANCH_PREFIX}' branch found to finish."
              exit 1
            elif [ "$num_matching" -gt 1 ]; then
              echo "Error: More than one '${BRANCH_PREFIX}' branch found. Please manually resolve or specify which to finish."
              echo "Found branches:"
              printf '%s\n' "$matching_branches"
              exit 1
            else
              TARGET_BRANCH="$matching_branches"
              # Extract version from branch name (e.g., "release/1.2.3" -> "1.2.3")
              # --- Use the escaped prefix in the sed command ---
              OP_VERSION=$(echo "$TARGET_BRANCH" | sed "s/^$ESCAPED_BRANCH_PREFIX//")
              echo "Operation: FINISH. Detected Version: $OP_VERSION, Branch: $TARGET_BRANCH"
            fi
          fi

          if [ -z "$OP_VERSION" ] || [ -z "$TARGET_BRANCH" ]; then
            echo "Error: Could not determine operation version or target branch."
            exit 1
          fi

          echo "operation_version=$OP_VERSION" >> "$GITHUB_OUTPUT"
          echo "target_branch=$TARGET_BRANCH" >> "$GITHUB_OUTPUT"
          echo "detected_operation_branch=$TARGET_BRANCH" >> "$GITHUB_ENV" # For use in subsequent steps
          echo "detected_operation_version=$OP_VERSION" >> "$GITHUB_ENV" # For use in subsequent steps
          
      - name: Display Operation Info ðŸ“£
        run: |
          echo "ðŸ“¦ Operation: ${{ github.event.inputs.operation }}"
          echo "ðŸ“¦ Version for this operation: ${{ steps.detect_op_info.outputs.operation_version }}"
          echo "ðŸ“¦ Target Branch: ${{ steps.detect_op_info.outputs.target_branch }}"

      # -------------------------------------------------------------------
      # ðŸš€ Start Release
      # Creates a release branch from develop and bumps version on it
      - name: Start Release Branch ðŸŒ¿
        if: github.event.inputs.operation == 'start-release'
        env:
          TARGET_BRANCH: ${{ steps.detect_op_info.outputs.target_branch }} # Use detected branch
        run: |
          echo "Creating release branch: $TARGET_BRANCH from develop"
          git checkout develop
          git pull origin develop # Ensure develop is up-to-date
          git checkout -b "$TARGET_BRANCH"
          git push origin "$TARGET_BRANCH"
          echo "Release branch '$TARGET_BRANCH' created successfully."

      # -------------------------------------------------------------------
      # ðŸš‘ Start Hotfix
      # Creates a hotfix branch from main and bumps version on it
      - name: Start Hotfix Branch ðŸ› ï¸
        if: github.event.inputs.operation == 'start-hotfix'
        env:
          TARGET_BRANCH: ${{ steps.detect_op_info.outputs.target_branch }} # Use detected branch
        run: |
          echo "Creating hotfix branch: $TARGET_BRANCH from main"
          git checkout main
          git pull origin main # Ensure main is up-to-date
          git checkout -b "$TARGET_BRANCH"
          git push origin "$TARGET_BRANCH"
          echo "Hotfix branch '$TARGET_BRANCH' created successfully."

      # -------------------------------------------------------------------
      # Bump version files (applies to both release and hotfix start branches)
      - name: Bump version in project files (if applicable) â¬†ï¸
        if: startsWith(github.event.inputs.operation, 'start-')
        env:
          NEW_VERSION: ${{ steps.detect_op_info.outputs.operation_version }}
          TARGET_BRANCH: ${{ steps.detect_op_info.outputs.target_branch }} # Use detected branch
          # Set VERSION_FILE in your workflow's environment if needed, e.g., for a custom file
          # VERSION_FILE: './src/version.txt'
        run: |
          git checkout ${{ env.TARGET_BRANCH }} # Checkout the newly created branch

          CHANGES_MADE=false

          if [ -f package.json ]; then
            echo "Bumping version in package.json to $NEW_VERSION"
            jq --arg v "$NEW_VERSION" '.version = $v' package.json > tmp.json && mv tmp.json package.json
            git add package.json
            CHANGES_MADE=true
          fi

          if [ -f composer.json ]; then
            echo "Bumping version in composer.json to $NEW_VERSION"
            jq --arg v "$NEW_VERSION" '.version = $v' composer.json > tmp.json && mv tmp.json composer.json
            git add composer.json
            CHANGES_MADE=true
          fi

          if [ -n "${VERSION_FILE}" ] && [ -f "${VERSION_FILE}" ]; then
            echo "Bumping version in $VERSION_FILE to $NEW_VERSION"
            sed -i "s/\(VERSION\s*=\s*['\"]\)[^'\"]\+\(['\"]\)/\1${NEW_VERSION}\2/" "$VERSION_FILE"
            git add "$VERSION_FILE"
            CHANGES_MADE=true
          fi

          if [ "$CHANGES_MADE" = true ]; then
            git commit -m "chore: bump version to $NEW_VERSION"
            git push origin ${{ env.TARGET_BRANCH }}
            echo "Version bump committed and pushed to ${{ env.TARGET_BRANCH }}"
          else
            echo "No version files found or changes needed. Skipping commit."
          fi

      # -------------------------------------------------------------------
      # âœ… Finish Release (Merge release branch to main and develop)
      - name: Finish Release Branch - Merge to Main ðŸŽ¯
        if: github.event.inputs.operation == 'finish-release'
        id: merge_release_to_main
        env:
          BRANCH_TO_MERGE: ${{ steps.detect_op_info.outputs.target_branch }} # Use auto-detected branch
          TARGET_BASE_BRANCH: main
          GH_TOKEN: ${{ secrets.GH_PAT }}
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Release ${{ env.BRANCH_TO_MERGE }} into Main`,
              head: env.BRANCH_TO_MERGE,
              base: env.TARGET_BASE_BRANCH,
              body: `Merging release branch \`${env.BRANCH_TO_MERGE}\` into \`${env.TARGET_BASE_BRANCH}\`.`,
              draft: false
            });
            console.log(`ðŸŸ¢ Created PR #${pr.number} for ${env.BRANCH_TO_MERGE} -> ${env.TARGET_BASE_BRANCH}`);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: "squash"
            });
            console.log(`âœ… Merged PR #${pr.number}`);

      - name: Create Git Tag on Main ðŸ·ï¸
        if: github.event.inputs.operation == 'finish-release'
        run: |
          TAG_NAME="v${{ steps.detect_op_info.outputs.operation_version }}"
          echo "Creating tag $TAG_NAME on main"
          git checkout main
          git pull origin main # Ensure main is up-to-date
          git tag "$TAG_NAME"
          git push origin "$TAG_NAME"
          echo "Tag '$TAG_NAME' created and pushed."

      - name: Finish Release Branch - Merge to Develop ðŸŒ¿
        if: github.event.inputs.operation == 'finish-release'
        id: merge_release_to_develop
        env:
          BRANCH_TO_MERGE: ${{ steps.detect_op_info.outputs.target_branch }} # Use auto-detected branch
          TARGET_BASE_BRANCH: develop
          GH_TOKEN: ${{ secrets.GH_PAT }}
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Merge Release ${{ env.BRANCH_TO_MERGE }} into Develop`,
              head: env.BRANCH_TO_MERGE,
              base: env.TARGET_BASE_BRANCH,
              body: `Merging release branch \`${env.BRANCH_TO_MERGE}\` into \`${env.TARGET_BASE_BRANCH}\` after merging to main.`,
              draft: false
            });
            console.log(`ðŸŸ¢ Created PR #${pr.number} for ${env.BRANCH_TO_MERGE} -> ${env.TARGET_BASE_BRANCH}`);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: "squash"
            });
            console.log(`âœ… Merged PR #${pr.number}`);

      - name: Clean up Release Branch ðŸ§¹
        if: github.event.inputs.operation == 'finish-release'
        run: |
          BRANCH_TO_DELETE="${{ steps.detect_op_info.outputs.target_branch }}"
          echo "Deleting release branch $BRANCH_TO_DELETE"
          git push origin --delete "$BRANCH_TO_DELETE" || true # Use || true to prevent failure if branch already deleted
          echo "Release branch '$BRANCH_TO_DELETE' deleted."

      # -------------------------------------------------------------------
      # âœ… Finish Hotfix (Merge hotfix branch to main and develop)
      - name: Finish Hotfix Branch - Merge to Main ðŸš‘
        if: github.event.inputs.operation == 'finish-hotfix'
        id: merge_hotfix_to_main
        env:
          BRANCH_TO_MERGE: ${{ steps.detect_op_info.outputs.target_branch }} # Use auto-detected branch
          TARGET_BASE_BRANCH: main
          GH_TOKEN: ${{ secrets.GH_PAT }}
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Hotfix ${{ env.BRANCH_TO_MERGE }} into Main`,
              head: env.BRANCH_TO_MERGE,
              base: env.TARGET_BASE_BRANCH,
              body: `Merging hotfix branch \`${env.BRANCH_TO_MERGE}\` into \`${env.TARGET_BASE_BRANCH}\`.`,
              draft: false
            });
            console.log(`ðŸŸ¢ Created PR #${pr.number} for ${env.BRANCH_TO_MERGE} -> ${env.TARGET_BASE_BRANCH}`);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: "squash"
            });
            console.log(`âœ… Merged PR #${pr.number}`);

      - name: Create Git Tag on Main (for Hotfix) ðŸ”–
        if: github.event.inputs.operation == 'finish-hotfix'
        run: |
          TAG_NAME="v${{ steps.detect_op_info.outputs.operation_version }}"
          echo "Creating tag $TAG_NAME on main"
          git checkout main
          git pull origin main # Ensure main is up-to-date
          git tag "$TAG_NAME"
          git push origin "$TAG_NAME"
          echo "Tag '$TAG_NAME' created and pushed."

      - name: Finish Hotfix Branch - Merge to Develop ðŸŒ¿
        if: github.event.inputs.operation == 'finish-hotfix'
        id: merge_hotfix_to_develop
        env:
          BRANCH_TO_MERGE: ${{ steps.detect_op_info.outputs.target_branch }} # Use auto-detected branch
          TARGET_BASE_BRANCH: develop
          GH_TOKEN: ${{ secrets.GH_PAT }}
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Merge Hotfix ${{ env.BRANCH_TO_MERGE }} into Develop`,
              head: env.BRANCH_TO_MERGE,
              base: env.TARGET_BASE_BRANCH,
              body: `Merging hotfix branch \`${env.BRANCH_TO_MERGE}\` into \`${env.TARGET_BASE_BRANCH}\` after merging to main.`,
              draft: false
            });
            console.log(`ðŸŸ¢ Created PR #${pr.number} for ${env.BRANCH_TO_MERGE} -> ${env.TARGET_BASE_BRANCH}`);
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: "squash"
            });
            console.log(`âœ… Merged PR #${pr.number}`);

      - name: Clean up Hotfix Branch ðŸ§¹
        if: github.event.inputs.operation == 'finish-hotfix'
        run: |
          BRANCH_TO_DELETE="${{ steps.detect_op_info.outputs.target_branch }}"
          echo "Deleting hotfix branch $BRANCH_TO_DELETE"
          git push origin --delete "$BRANCH_TO_DELETE" || true
          echo "Hotfix branch '$BRANCH_TO_DELETE' deleted."

      - name: Create GitHub release (if needed, after a finish operation) ðŸš€
        if: startsWith(github.event.inputs.operation, 'finish-')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.detect_op_info.outputs.operation_version }}
          name: Release ${{ steps.detect_op_info.outputs.operation_version }}
          generate_release_notes: true
          # target_commitish: main # Ensure release is tied to main's commit
          
